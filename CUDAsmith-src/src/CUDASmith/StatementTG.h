// Statement that represents a section of code that will be used for TG
// (Equivalence Modulo Input) testing. These sections will be dead by
// construction, and so will never be executed. To prevent the compiler from
// statically determining that the code is dead, the test expression controlling
// access will use data initialised by the host.
//
// Once the program has been generated, an TG variant of the program will be
// generated by pruning the TG sections according to three probabilities:
// - p_compound: Probability of deleting a compound statement (if, for, ...).
// - p_leaf: Probability of deleting a simple statement (assign, break, ...).
// - p_lift: Probability of lifting the body of a compound statement up one
//   level to the parent block (if (...) {x = y; break;} -> x=y; break;).

#ifndef _CUDASMITH_STATEMENTTG_H_
#define _CUDASMITH_STATEMENTTG_H_

#include <memory>
#include <ostream>
#include <vector>

#include "CGContext.h"
#include "CUDASmith/CUDAStatement.h"
#include "CUDASmith/MemoryBuffer.h"
#include "CommonMacros.h"
#include "StatementIf.h"

class Block;
class FactMgr;
extern bool g_Mark;
extern bool g_Tgoff;

namespace CUDASmith
{

// Compound statement for an TG section of code.
// Basically just wraps around a StatementIf. Will handle pruning itself.
class StatementTG : public CUDAStatement
{
  public:
    StatementTG(Block *parent, StatementIf *if_block)
        : CUDAStatement(kTG, parent), if_block_(if_block)
    {
    }
    StatementTG(StatementTG &&other) = default;
    StatementTG &operator=(StatementTG &&other) = default;
    virtual ~StatementTG() {}

 
  // Factory method for creating an EMI block. This will just be the same as
  // creating a random StatementIf, but with more control over the test
  // expression.
  static StatementTG *make_random(CGContext& cg_context);

    // Remove statements from the block according to the three probabilities
    // outlined at the top.
    void Prune();

    // Pure virtual in Statement. Not really needed.
    void get_blocks(std::vector<const Block *> &blks) const
    {
        if_block_->get_blocks(blks);
    }
    void get_exprs(std::vector<const Expression *> &exps) const
    {
        if_block_->get_exprs(exps);
    }

    // Outputs the TG block. Nothing special required, delegate to StatementIf.
    void Output(std::ostream &out, FactMgr *fm, int indent) const
    {
        // cout<<"Output TG"<<endl;
        out<<"//This is TG condition"<<endl;
        //add by wxy 2018-03-20
        if (g_Tgoff)
        {
            g_Mark = true; //附上这个条件不输出tg语句
        }
        if(!g_Mark)
        {
           if_block_->output_condition(out,fm,0);
        }
    }

  private:
    // Prune helper function. Pruning is performed recursively, calling this
    // function each time a block is entered.
    void PruneBlock(Block *block);

    // Helper for PruneBlock. Merge the second block into the first, invalidating
    // the second block. Position specifies where the statements are inserted,
    // returns an iterator to the last statement.
    std::vector<Statement *>::iterator MergeBlock(
        std::vector<Statement *>::iterator position, Block *former, Block *merger);
    // TEMP helper for prune that removes conts and breaks from nested blocks.
    // Will remove when I get around to fixing the walker.
    void RemoveBreakContinue(Block *block);

    // If statement being wrapped.
    std::unique_ptr<StatementIf> if_block_;

    DISALLOW_COPY_AND_ASSIGN(StatementTG);
};

// Collects each TG instance, and handles the input data required by each
// instance.
class TGController
{
  public:
    explicit TGController(MemoryBuffer *tg_input)
        : tg_input_(tg_input), itemised_tg_input_({tg_input})
    {
    }
    TGController(TGController &&other) = default;
    TGController &operator=(TGController &&other) = default;
    virtual ~TGController() {}

    // Accessors for a singleton instance of the controller. The instance will be
    // created lazily.
    static TGController *GetTGController();
    static void ReleaseTGController();

    // Factory for creating a controller. Will create a memory buffer.
    static TGController *CreateTGController();

    // Add an emi section that will later be pruned.
    void AddStatementTG(StatementTG *tg) { tg_sections_.push_back(tg); }

    // Remove an emi section. It is down to the Statement TG to remove itself
    // from the controller. Returns true if something was removed.
    bool RemoveStatementTG(StatementTG *tg);

    // Add an itemised reference to the emi inpu data.
    void AddItemisedTGInput(MemoryBuffer *item);

    // Performs pruning on all TG sections that have been added to the
    // controller. This should be done as a post-process, after the program has
    // been completely generated.
    void PruneTGSections();

    // Get the memory buffer that holds the data used for the test expressions.
    MemoryBuffer *GetTGInput() { return tg_input_.get(); }
    // Get the vector of all references to the emi input.
    std::vector<MemoryBuffer *> *GetItemisedTGInput()
    {
        return &itemised_tg_input_;
    }

  private:
    // All StatementTGs are collected here. (Should probably use a list)
    std::vector<StatementTG *> tg_sections_;
    // Input data for the test expressions.
    std::unique_ptr<MemoryBuffer>tg_input_;
    std::vector<MemoryBuffer *> itemised_tg_input_;

    DISALLOW_COPY_AND_ASSIGN(TGController);
};

} // namespace CUDASmith

#endif // _CUDASMITH_STATEMENTTG_H_
